<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fp | Troika Tech]]></title>
  <link href="http://troikatech.com/blog/categories/fp/atom.xml" rel="self"/>
  <link href="http://troikatech.com/"/>
  <updated>2015-08-18T14:19:05-03:00</updated>
  <id>http://troikatech.com/</id>
  <author>
    <name><![CDATA[Vitor Capela]]></name>
    <email><![CDATA[dodecaphonic@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Decoding larger JSON objects in Elm 0.15]]></title>
    <link href="http://troikatech.com/blog/2015/08/17/decoding-larger-json-objects-in-elm/"/>
    <updated>2015-08-17T22:31:00-03:00</updated>
    <id>http://troikatech.com/blog/2015/08/17/decoding-larger-json-objects-in-elm</id>
    <content type="html"><![CDATA[<p><a href="http://elm-lang.org/">Elm</a> is pretty cool. It&rsquo;s a functional programming language with a <a href="https://www.youtube.com/watch?v=oYk8CKH7OhE">focus on usability</a>, strongly-typed but unceremonious, with nice type inferencing, good documentation and great stewardship from its creator, <a href="http://evan.czaplicki.us/">Evan Czaplicki</a>.</p>

<p>It&rsquo;s so cool I&rsquo;ve given an excited talk about it at work after only a couple of weeks of fiddling with it. And whenever I speak about tech, I try to add a demo or two to tie things together and make points clearer. That led to <a href="https://github.com/dodecaphonic/elm-forecast">elm-forecast</a>, a tiny app showing how to call APIs, decode JSON and display things on the screen.</p>

<p><img src="https://s3.amazonaws.com/troikatech/elm_json/elm-forecast.gif" alt="What elm-forecast looks like" /></p>

<h2>The problem</h2>

<p><a href="https://developer.forecast.io/">Dark Sky&rsquo;s JSON API</a> offers detailed weather information for most of the world. It has up-to-the minute data for some locations, and powers a lot of nice weather apps, like <a href="http://forecast.io">forecast.io</a> and <a href="https://play.google.com/store/apps/details?id=com.samruston.weather&amp;hl=en">Weather Timeline</a>. My app was also going to be nice, so I picked it as my data source.</p>

<p>I started by wrapping the current forecast definition as a <a href="http://elm-lang.org/docs/records">record</a>:</p>

<p>```haskell
type alias Forecast = { time : Int</p>

<pre><code>                  , summary : String
                  , icon : String
                  , precipIntensity : Float
                  , precipProbability : Float
                  , temperature : Float
                  , windSpeed : Float
                  , windBearing : Float
                  , humidity : Float
                  , visibility : Float
                  , cloudCover : Float
                  , pressure : Float
                  , ozone : Float
                  }
</code></pre>

<p>```</p>

<p>Record types marry a lot of the feel of JavaScript objects with static types (the things after the colons).</p>

<p>If you&rsquo;re familiar with dynamic languages, the next step will seem alien: instead of just calling something like <code>JSON.parse(obj)</code> and referencing its fields, we have to tell Elm how to make a typed <code>Forecast</code> out of the serialized data.</p>

<p>Let&rsquo;s see what it looks like with a smaller object:</p>

<p>```haskell
$ elm repl
Elm REPL 0.4.2 (Elm Platform 0.15.1)
  See usage examples at <a href="https://github.com/elm-lang/elm-repl">https://github.com/elm-lang/elm-repl</a>
  Type :help for help, :exit to exit</p>

<blockquote><p>import Json.Decode as Json exposing ((:=))
type alias Point = { x: Float, y: Float }
serialized = &ldquo;{\"x\&rdquo;: -43.123, \&ldquo;y\&rdquo;: -22.321}&ldquo;
&rdquo;{\&ldquo;x\&rdquo;: -43.123, \&ldquo;y\&rdquo;: -22.321}&ldquo; : String
pointDecoder = Json.object2 \
|   Point \
|   ("x&rdquo; := Json.float) \
|   (&ldquo;y&rdquo; := Json.float)
<function> : Json.Decode.Decoder Repl.Point
Json.decodeString pointDecoder serialized
Ok { x = -43.123, y = -22.321 } : Result.Result String Repl.Point
```</p></blockquote>

<p>The code above defines a type <code>Point</code> and a <code>Json.Decode.Decoder</code> <code>pointDecoder</code>, which takes care of deserializing an object with two fields (<code>object2</code>) and returning a <code>Point</code>. As you can see, no types have been declared, yet Elm has inferred every single one of them.</p>

<p><code>Json.Decode</code> has functions from <code>object1</code> to <code>object8</code>, capable of building objects with one up to eight fields. What to do with <code>Forecast</code>, that has <strong>13</strong>? <em>&ldquo;Throw away five things, it&rsquo;s just an example app you&rsquo;re building to learn Elm&rdquo;</em>, thought the lazy author. Luckily, thirst for knowledge (and a little guilt) averted that course, and I relied on what little function programming I know to <em>almost</em> get there using <a href="http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Json-Decode#andThen"><code>Json.Decoder.andThen</code></a>. Since <em>almost</em> is actually <em>not quite</em>, to Google I went. <a href="https://groups.google.com/forum/m/#!topic/elm-discuss/2LxEUVe0UBo">A thread with a recipe from mr. Czaplicki himself</a> offered the following solution:</p>

<p>```haskell
import Json.Decode as Json</p>

<p>apply : Json.Decoder (a &ndash;> b) &ndash;> Json.Decoder a &ndash;> Json.Decoder b
apply func value =</p>

<pre><code>Json.object2 (&lt;|) func value
</code></pre>

<p>```</p>

<p>Let&rsquo;s see it in action:</p>

<p>```haskell</p>

<blockquote><p>newPointDecoder = Json.map Point (&ldquo;x&rdquo; := Json.float) <code>apply</code> (&ldquo;y&rdquo; := Json.float)
<function> : Json.Decode.Decoder Repl.Point
Json.decodeString newPointDecoder serialized
Ok { x = -43.123, y = -22.321 } : Result.Result String Repl.Point
```</p></blockquote>

<p>With <code>apply</code>, you can chain as many decoders as you like and build <code>objectN</code>. But how does it work?</p>

<h2>A detour to the world of Partial Application</h2>

<p>In Elm, like in Haskell, every function is <em>curried</em>. What it means, in practice, is that every function takes a single argument and returns a value, which can in turn be another function, taking a single argument, returning a value, and so forth. I&rsquo;ll define a function <code>add</code> that (oh, how impressive) adds two numbers:</p>

<p>```haskell</p>

<blockquote><p>add x y = x + y
<function> : number &ndash;> number &ndash;> number
add 2 3
5 : number
```</p></blockquote>

<p>It looks like a function call with two arguments, like you see in most other languages. But look at the type signature the compiler inferred: <code>add : number -&gt; number -&gt; number</code>. What do the arrows represent? Well, they tell you exactly that the paragraph above tries to explain. Let&rsquo;s see:</p>

<p>```haskell</p>

<blockquote><p>add2 = add 2
<function> : number &ndash;> number
add2 3
5 : number
```</p></blockquote>

<p>When defining <code>add2</code>, I&rsquo;ve <em>partially</em> applied <code>add</code> with <code>2</code>, getting another function (now from <code>number -&gt; number</code>). Calling that function will then result in a final number, the <code>5</code> literal that amazes people all over the world. This very characteristic helps you build <code>apply</code>.</p>

<p>In the example a few paragraphs above, <code>Point</code> is a function with the signature <code>Float -&gt; Float -&gt; Point</code>. That means that if I try to use it with a single decoder, it will move closer to getting an actual <code>Point</code>, but not get there yet:</p>

<p>```haskell</p>

<blockquote><p>Json.map Point (&ldquo;x&rdquo; := Json.float)
<function> : Json.Decode.Decoder (Float &ndash;> Repl.Point)
```</p></blockquote>

<p>Looking at the type signature, it&rsquo;s structure that decodes a <code>Float</code> and returns another structure that can decode a function <code>Float -&gt; Point</code>. If I tried to do the same thing with a type constructor that took more arguments, say <code>Float -&gt; String -&gt; Bool -&gt; String -&gt; Value</code>, the first step would yield a Decoder with type <code>(String -&gt; Bool -&gt; String -&gt; Value)</code> &mdash; solved for the first parameter, still waiting for a resolution for the next three.</p>

<p>What <code>apply</code> does then is leverage the fact that you can progressively get to your final value by applying function by function, taking care of spitting out every every step as a <code>Json.Decoder</code>. There&rsquo;s a name for this pattern of having a function in a box and applying it to values in other boxes: it&rsquo;s an <a href="https://wiki.haskell.org/Typeclassopedia#Applicative">Applicative functor</a>). If you&rsquo;ve read a bit about the language, you know that Elm shies away from the burden of a Math-y, Haskell-y lexicon. The great thing is that by hiding the words but showing things in practice, you end up building an intuition for how the concepts can be <em>useful</em>.</p>

<p>Let&rsquo;s go back to <code>Json.object2</code>. It expects <code>(a -&gt; b -&gt; c) -&gt; Decoder a -&gt; Decoder b -&gt; Decoder c</code> &mdash; a function from type <code>a</code> to <code>b</code> to <code>c</code> and <code>Decoder</code>s for <code>a</code> and <code>b</code>, yielding a <code>Decoder c</code>. In our definition <code>pointDecoder</code> in the beginning of this post, we matched that to a tee, as <code>Point</code> can be seen as a function taking two <code>Floats</code> (<code>a</code> and <code>b</code>) and returning a <code>Point</code> record (<code>c</code>). But <code>a</code>, <code>b</code> or <code>c</code> can also be a function! In fact, that&rsquo;s exactly what we&rsquo;ve seen above with <code>Json.Decode.Decoder (Float -&gt; Repl.Point)</code>. Thus, when we say:</p>

<p>```haskell</p>

<blockquote><p>Json.object2 (&lt;|) func value
```</p></blockquote>

<p>and replace <code>func</code> with <code>Json.Decoder.Decode (Float -&gt; Point)</code> and <code>value</code> with <code>("y" := Json.float)</code>, we&rsquo;ll end up with a <code>Decoder</code> built of applying what&rsquo;s coming out of <code>value</code> to <code>Float -&gt; Point</code>, arriving at <code>Decoder Point</code>. If we manually try to build the same chain, it looks like this:</p>

<p>```haskell</p>

<blockquote><p>import Json.Decode as Json exposing ((:=), andThen)
type alias Point = { x: Float, y: Float }
partialDecoder = Json.succeed(Point) <code>andThen</code> \</p>

<pre><code>(\f -&gt; ("x" := Json.float) `andThen` \
(\x -&gt; Json.succeed &lt;| f x))
</code></pre>

<p><function> : Json.Decode.Decoder (Float &ndash;> Repl.Point)
decoderPoint = partialDecoder <code>andThen</code> \</p>

<pre><code>(\f -&gt; ("y" := Json.float) `andThen` \
(\y -&gt; Json.succeed &lt;| f y))
</code></pre>

<p><function> : Json.Decode.Decoder Repl.Point
```</p></blockquote>

<p>Cool, right? Now that you and I understand the technique, we can go back to the gif above and marvel at how poor my CSS skills are.</p>

<h2>No magic</h2>

<p>What I find the most refreshing as I dive into functional programming is that there&rsquo;s (usually) no magic. If you start peeling the layers, there&rsquo;s just functions brought together to perform amazing things. <code>apply</code> here is exactly that: the power of a few functions allowing you to convert arbitrarily large structures into a nice type Elm can understand. In a world of &ldquo;factory this&rdquo; &ldquo;IoC container that&rdquo;, you can&rsquo;t help but smile. And it REALLY REALLY REALLY improves your programming everywhere: I&rsquo;m a fan of saying my Ruby is much better and more maintainable after I decided to learn the functional ways because it&rsquo;s true. Hopefully you can find the same joy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maybe Haskell]]></title>
    <link href="http://troikatech.com/blog/2015/04/02/maybe-haskell/"/>
    <updated>2015-04-02T08:06:00-03:00</updated>
    <id>http://troikatech.com/blog/2015/04/02/maybe-haskell</id>
    <content type="html"><![CDATA[<p>The programming world is one of trends and fashions. One week you&rsquo;re on the top of the world for using that NoSQL database, and then you&rsquo;re very wrong the next; one day it&rsquo;s all about Rails, the next it&rsquo;s node.js, now it&rsquo;s Go. Using <a href="http://news.ycombinator.com">Hacker News</a> as a compass seemingly means discarding everything you&rsquo;re doing now to follow the next big thing.</p>

<p>Like fashion, though, sometimes one of those new things is actually well-rounded, makes a mark and becomes permanent. Also like fashion, the new thing might be an old thing that people are rediscovering or just now ready to adopt. Judging by what&rsquo;s on the specialized news, <a href="http://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> is the old-new rage that&rsquo;s changing the world and is here to stay.</p>

<p>It&rsquo;s no wonder: more enlightened programmers and language designers have sprinkled some of the joys of that paradigm upon our OO tools, making us giggle with happiness when chaining <code>map</code>s and <code>inject</code>s and taking blocks to change a method&rsquo;s behavior, or using anonymous and higher-order functions in tired and uncool languages of yesteryear, feeling more productive all the way. It&rsquo;s so transformative to think in pipelines and in functional composition that we end up wanting to know how to learn more and feel <em>even better</em>. Functional Programming called, and you answered.</p>

<p>But lo!, what is a catamorphism? What the hell is a Category, and why does it need a theory? Why did someone put a Monad in my burrito? Is Functor just a funny word Erik Meijer says?</p>

<p>Let&rsquo;s face it: it can be daunting. None of the usual landmarks of what we call <em>programming</em> are there to guide you through learning, and it&rsquo;s easy to feel inadequate and, dare I say it, intellectually inferior. Fear not: <a href="https://twitter.com/patbrisbin">Pat Brisbin</a> knows this, and is here to help.</p>

<h2>The Book</h2>

<p><a href="http://maybe-haskell.com">&ldquo;Maybe Haskell&rdquo;</a>, written by the aforementioned mr. Brisbin, is a book of the short and sweet kind. It quickly acknowledges that it probably will not be the definitive guide on any of the subjects it talks about, and moves right on to the material.</p>

<p>From the gates, the author explains referential transparency and uses equational reasoning to show you how a name for an expression (let&rsquo;s say <code>add(x, y)</code>) can be replaced safely by the expression itself (<code>x + y</code>). This will become a tool later on to clarify that what seems so elaborate is actually pretty straightforward. It&rsquo;s very effective, because it unfolds everything that looks so terse and codified into its components, and those components into their components, working as both a calming device (&ldquo;see how simple it is? It&rsquo;s just about context&rdquo;) and an illustration of the power of function composition.</p>

<p>It then gets to its main thread: what is the <code>Maybe</code> type and how is it built? What does it mean to adopt <code>Maybe</code> in a code base, and how do you deal with it without having every function in your system taking and returning other <code>Maybe</code>s? Even if you&rsquo;ve heard of or applied <code>Maybe</code>, it might give you ideas and reveal unknown subtleties &mdash; especially if all you&rsquo;ve learned about it has been self-directed.</p>

<p>From that on you&rsquo;ll hit three head-scratchers in sequence: Functors, Applicatives and Monads. It begins with showing you ways of not infecting your code with <code>Maybe</code> everywhere and ends with calling functions that take multiple <code>Maybe</code>s, dealing with the possibility of one or more of them not being there. The path is of full of little joys and insights to savor, and you&rsquo;ll get what a Monad <em>does</em> by the end of it (even if the answer to what it <em>is</em> goes through endofunctors and other details).</p>

<p>What I greatly enjoyed was the &ldquo;Other Types&rdquo; section. It&rsquo;s brief, but tackles how you can use the same building blocks to improve designs and make errors and side-effects more explicit. While I knew most of the benefits and the material, I thought about the complete novice and how that section could spark new ideas. I didn&rsquo;t &ldquo;ooh&rdquo; and &ldquo;aah&rdquo; because it was new to me: I did because it will hook a lot of casually interested people who perhaps got the book because it came from someone in the Ruby world and aren&rsquo;t very invested in the ideas of FP yet. It will definitely make <em>Ruby</em>, if nothing else, better.</p>

<p>In the end, even if &ldquo;Maybe Haskell&rdquo; just explains enough of what the language can do to support the examples, the quiet imponence and lack of pretense of the language become very evident. As the text progresses, you&rsquo;ll see the ivory tower where FP wizards live for what it really is: a building that begins on the same ground you and I step on, made out of very solid and simple materials. Luckily we have Pat gently guiding us to that conclusion.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Programming in Ruby]]></title>
    <link href="http://troikatech.com/blog/2014/07/07/functional-programming-in-ruby/"/>
    <updated>2014-07-07T21:29:00-03:00</updated>
    <id>http://troikatech.com/blog/2014/07/07/functional-programming-in-ruby</id>
    <content type="html"><![CDATA[<p>On June 21th, 2014, I gave a talk about Functional Programming in Ruby in one of <a href="http://rubyonrio.org">RubyOnRio&rsquo;s</a> monthly meetings. I decided to do a short overview of some concepts and techniques in the FP world and then go over <a href="https://twitter.com/garybernhardt">Gary Bernhardt&rsquo;s</a> &ldquo;<a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">Functional Core, Imperative Shell</a>&rdquo; &mdash; after all, it would be a hard sell if I couldn&rsquo;t show a way said techniques make your everyday coding better.</p>

<p>It didn&rsquo;t get recorded this time, but I thought the slides could be interesting. Here they are.</p>

<script async class="speakerdeck-embed" data-id="77fedf60ddbf0131b761266a7d836638" data-ratio="1.34031413612565" src="http://speakerdeck.com/assets/embed.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Property-based testing in Ruby]]></title>
    <link href="http://troikatech.com/blog/2014/04/02/property-based-testing-in-ruby/"/>
    <updated>2014-04-02T10:32:00-03:00</updated>
    <id>http://troikatech.com/blog/2014/04/02/property-based-testing-in-ruby</id>
    <content type="html"><![CDATA[<p>For the past year or so I have slowly been dipping my feet into the vast functional programming seas. From taking the awesome <a href="http://coursera.org">Coursera</a> <a href="https://www.coursera.org/course/progfun">offerings</a> <a href="https://www.coursera.org/course/reactive">from Typesafe</a> to slowly working through Rúnar Bjarnason&rsquo;s and Paul Chiusano&rsquo;s <em><a href="http://www.manning.com/bjarnason/">Functional Programming in Scala</a></em>, my mind has been expanding proportionally to the time I dedicate to learning its ways. It has been incredibly rewarding and humbling.</p>

<p>One such reward has been coming into direct touch with property-based testing. This technique, first developed by <a href="http://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a> in Haskell-land, spins automated testing on its head: instead of codifying what is proper behavior by asserting that the outputs for given inputs match what is expected, the tester establishes logical properties about what should happen and lets the tool generate loads of inputs to check if they hold. If something goes wrong, the tool will then try to find the smallest test input that breaks the property (<em>falsifies</em> it), a process called <em>shrinking</em>; if it can&rsquo;t find anything, you can sigh with relief and think about what to scrutinize next.</p>

<p>Having a QuickCheck-like tool at your disposal can be incredibly powerful. The more complex the software or the algorithm, the greater the likelihood of your carefully curated unit and integration tests having blind spots. <a href="http://basho.com">Basho</a>, for instance, <a href="http://basho.com/quickchecking-poolboy-for-fun-and-profit/">have written about the stark realization that their worker pool library was full of subtle bugs by using QuickCheck for Erlang</a>, and you can find <a href="http://www.quviq.com/documents/erlang001-arts.pdf">other</a> <a href="http://www.autosar.org/download/conferencedocs11/12_AUTOSAR_ModelBased_Quviq.pdf">instances</a> of how the technique helped make better software.</p>

<p>I don&rsquo;t know about you, but when I come in contact with stuff like that I immediately think of how improved parts of my day job would be if I just could apply it. Considering that my daily duties are conducted in Ruby, I felt it was time I explored the subject in that realm.</p>

<h2>A contrived setup that hopefully shows how it can work out</h2>

<p>Let&rsquo;s say we&rsquo;ve decided to implement our own linked list class in Ruby. We would probably start our implementation with something like this:</p>

<p>``` ruby &ldquo;List&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list-rb">https://gist.github.com/dodecaphonic/9934064#file-list-rb</a>
require &ldquo;singleton&rdquo;</p>

<p>class Nil
  include Singleton</p>

<p>  def empty?; true; end</p>

<p>  def to_s</p>

<pre><code>"Nil"
</code></pre>

<p>  end
end</p>

<p>class Cons
  def initialize(head, tail = Nil.instance)</p>

<pre><code>@head = head
@tail = tail
</code></pre>

<p>  end</p>

<p>  attr_reader :head, :tail</p>

<p>  def empty?; false; end</p>

<p>  def to_s</p>

<pre><code>"(#{head} . #{tail.to_s})"
</code></pre>

<p>  end
end
```</p>

<p>Using that <em>very</em> convenient API, we can build lists:</p>

<p>``` ruby</p>

<blockquote><blockquote><p>l = Cons.new(1, Cons.new(2, Cons.new(3, Nil.instance)))
l.to_s # => &ldquo;(1 . (2 . (3 . Nil)))&rdquo;
```</p></blockquote></blockquote>

<p>We know that, in a linked list, adding to the head is O(1), while appending to the end is O(n). So we build algorithms that respect its efficiency guarantees. However, when we, say, map this list into another list, it results in the following situation:</p>

<p>``` ruby &ldquo;List&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list-rb">https://gist.github.com/dodecaphonic/9934064#file-list-rb</a>
def do_something_amazing(list, acc = Nil.instance)
  super_value = list.head * 1337
  if list.tail.empty?</p>

<pre><code>acc
</code></pre>

<p>  else</p>

<pre><code>do_something_amazing(list.tail, List.new(super_value, acc))
</code></pre>

<p>  end
end</p>

<blockquote><blockquote><p>do_something(l).to_s # => &ldquo;(4011 . (2674 . (1337 . Nil)))&rdquo;
```</p></blockquote></blockquote>

<p>Processing things from head to tail means the list ends up reversed. It&rsquo;s common, then, to reverse it back when we&rsquo;re done processing, to preserve the order an external user would expect. Let&rsquo;s add a <code>reverse</code> method to a <code>List</code> helper module:</p>

<p>``` ruby &ldquo;List&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list-rb">https://gist.github.com/dodecaphonic/9934064#file-list-rb</a>
module List
  def self.reverse(list, acc = Nil.instance)</p>

<pre><code>if list.empty?
  acc
else
  reverse(list.tail, Cons.new(list.head, acc))
end
</code></pre>

<p>  end
end
```</p>

<p>So when we try to reverse what was created in <code>do_something_amazing</code>, we get what we need:</p>

<p><code>ruby
List.reverse(do_something_amazing(l)).to_s # =&gt; "(1337 . (2674 . (4011 . Nil)))"
</code></p>

<p>Awesome. I think this is enough for us to start exploring properties. If you&rsquo;re getting bored, take a sip of coffee and come back when you&rsquo;re ready. There&rsquo;s a few cool tricks below the fold.</p>

<h2>Testing the old way</h2>

<p>Being the good developers we are, we are covering that code with tests:</p>

<p>``` ruby &ldquo;List Tests&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list_test-rb">https://gist.github.com/dodecaphonic/9934064#file-list_test-rb</a>
class ListTest &lt; MiniTest::Test
  def test_reversing_lists</p>

<pre><code>assert_equal "(3 . (2 . (1 . Nil)))",
  List.reverse(Cons.new(1, Cons.new(2, Cons.new(3)))).to_s
assert_equal "(9 . (400 . (321 . (1 . (10 . Nil)))))",
  List.reverse(Cons.new(10, Cons.new(1, Cons.new(321, Cons.new(400, Cons.new(9)))))).to_s
assert_equal "Nil", List.reverse(Nil.instance).to_s
assert_equal "(1 . Nil)", List.reverse(Cons.new(1)).to_s
</code></pre>

<p>  end
end
```</p>

<p>We&rsquo;re pretty confident that&rsquo;s enough, even if it was kind of boring to do manually. That amount of testing would let us go home and sleep soundly.</p>

<h2>Testing the QuickCheck way</h2>

<p>First, we&rsquo;ll need something like QuickCheck in Ruby. The best, most idiomatic, most maintained, least-Monad-y thing I have found is <a href="https://github.com/hayeah/rantly">Rantly</a>. It has both primitive value generation built-in and property testing with shrinking. We&rsquo;ll skip over the basic API and go straight to defining a property to check if my algorithm is really bullet-proof. To aid in the creation of lists from Arrays, we&rsquo;ll add a new helper:</p>

<p>``` ruby &ldquo;List&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list-rb">https://gist.github.com/dodecaphonic/9934064#file-list-rb</a>
module List
  # &hellip;
  def self.from_values(*values)</p>

<pre><code>values.reverse.inject(Nil.instance) { |ls, v| Cons.new(v, ls) }
</code></pre>

<p>  end
end
```</p>

<p>To check that it works, let&rsquo;s change the existing tests and see if they still pass:</p>

<p>``` ruby &ldquo;List Tests&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list_test-rb">https://gist.github.com/dodecaphonic/9934064#file-list_test-rb</a>
class ListTest &lt; MiniTest::Test
  def test_reversing_lists</p>

<pre><code>assert_equal "(3 . (2 . (1 . Nil)))",
  List.reverse(List.from_values(1, 2, 3)).to_s
assert_equal "(9 . (400 . (321 . (1 . (10 . Nil)))))",
  List.reverse(List.from_values(10, 1, 321, 400, 9)).to_s
assert_equal "Nil", List.reverse(Nil.instance).to_s
assert_equal "(1 . Nil)", List.reverse(List.from_values(1)).to_s
</code></pre>

<p>  end
end
```</p>

<p>```
Run options: &mdash;seed 48889</p>

<h1>Running:</h1>

<p>.</p>

<p>Finished in 0.001256s, 796.1783 runs/s, 3184.7134 assertions/s.</p>

<p>1 runs, 4 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>Great. Now to the newfangled thing. As I mentioned before, writing a property to check requires us to think differently than we would with regular unit tests. Your formulation should state something logical, something that does not rely on specific inputs. Following that guideline, we can reason about reversing lists in the following manner:</p>

<p>``` ruby &ldquo;List Tests&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list2_test-rb">https://gist.github.com/dodecaphonic/9934064#file-list2_test-rb</a>
  # &hellip;
  def test_reversing_by_property</p>

<pre><code>property {
  length = range(0, 1_000_000)
  List.from_values(array(length) { integer })
}.check { |list|
  assert_equal list.to_s, List.reverse(List.reverse(list)).to_s
}
</code></pre>

<p>  end
  # &hellip;
```</p>

<p>The meat is in the <code>check</code> block. Determining that a list has been reversed correctly requires us to check if reversing it again gets us back to the original list. To seed our check, we build a <code>property</code> block that creats an array with a random length between 0 and 1_000_000, itself filled with random integers. Let&rsquo;s run the tests again:</p>

<p>```
$ bundle exec ruby list.rb
Run options: &mdash;seed 17130</p>

<h1>Running:</h1>

<p>.
&hellip;&hellip;&hellip;.
success: 100 tests
.</p>

<p>Finished in 121.969127s, 0.0164 runs/s, 0.8527 assertions/s.</p>

<p>2 runs, 104 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>It took a while (we wanted to be thorough, with those million-item arrays), but we&rsquo;re pretty sure it works. I&rsquo;m a believer and I&rsquo;m stoked; when I look at you, however, I see a face that says &ldquo;look, it&rsquo;s cool and all, but isn&rsquo;t it <em>kind of worthless</em>? The tests we had were telling us the same thing, and we only needed the power of our minds to generate the correct inputs. Why go through so much trouble?&rdquo;</p>

<p>Well, what about those times when ours minds fail us?</p>

<h2>Catching a bug with Rantly</h2>

<p>Let&rsquo;s say you&rsquo;re excited about building your own data structures and want to wrap that linked list inside a very inefficient Set. You mutter to yourself that you should make sure items are not inserted twice, which for now seems to be the main difference between Sets and Lists as storage containers.</p>

<p>You build a little more structure into what you already have, adding a <code>prepend</code> method and inlining <code>reverse</code> into a <code>List</code> base class:</p>

<p>```ruby &ldquo;List 2&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list2-rb">https://gist.github.com/dodecaphonic/9934064#file-list2-rb</a></p>

<p>class List
  def to_s</p>

<pre><code>raise "Don't use this directly, fool"
</code></pre>

<p>  end</p>

<p>  def empty?; true; end</p>

<p>  def prepend(v)</p>

<pre><code>Cons.new(v, self)
</code></pre>

<p>  end</p>

<p>  def reverse(acc = Nil.instance)</p>

<pre><code>if empty?
  acc
else
  tail.reverse(Cons.new(head, acc))
end
</code></pre>

<p>  end</p>

<p>  def self.from_values(*values)</p>

<pre><code>values.reverse.inject(Nil.instance) { |ls, v| Cons.new(v, ls) }
</code></pre>

<p>  end<br/>
end</p>

<p>class Nil &lt; List
  include Singleton</p>

<p>  def to_s</p>

<pre><code>"Nil"
</code></pre>

<p>  end
end</p>

<p>class Cons &lt; List
  def initialize(head, tail = Nil.instance)</p>

<pre><code>@head = head
@tail = tail
</code></pre>

<p>  end</p>

<p>  attr_reader :head, :tail</p>

<p>  def empty?; false; end</p>

<p>  def to_s</p>

<pre><code>"(#{head} . #{tail.to_s})"
</code></pre>

<p>  end
end
```</p>

<p>To check if an item exists, you add a <code>contains?</code> method:</p>

<p>``` ruby &ldquo;List with contains&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-list2-rb">https://gist.github.com/dodecaphonic/9934064#file-list2-rb</a>
class List
  # ..
  def contains?(v); false; end
  # ..
end</p>

<p>class Cons &lt; List
  # ..
  def contains?(v)</p>

<pre><code>head == v || tail.contains?(v)
</code></pre>

<p>  end
  # ..
end
```</p>

<p>Then you write your immutable Set and matching tests:</p>

<p>``` ruby &ldquo;A dumb set implementation&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-set-rb">https://gist.github.com/dodecaphonic/9934064#file-set-rb</a>
class DumbSet
  def initialize(storage = Nil.instance)</p>

<pre><code>@storage = storage
</code></pre>

<p>  end</p>

<p>  attr_reader :storage
  private     :storage</p>

<p>  def push(v)</p>

<pre><code>if !storage.contains?(v)
  DumbSet.new(storage.prepend(v))
else
  self
end
</code></pre>

<p>  end
  alias_method :&lt;&lt;, :push</p>

<p>  def contains?(v)</p>

<pre><code>storage.contains?(v)
</code></pre>

<p>  end</p>

<p>  def to_a</p>

<pre><code>values = []
list   = storage
until list.empty?
  values &lt;&lt; list.head
  list = list.tail
end
values
</code></pre>

<p>  end
end</p>

<p>class DumbSetTest &lt; Minitest::Test
  def setup</p>

<pre><code>@s = (((DumbSet.new &lt;&lt; 1) &lt;&lt; 2) &lt;&lt; 3)
</code></pre>

<p>  end</p>

<p>  attr_reader :s</p>

<p>  def test_contains</p>

<pre><code>assert s.contains?(3)
assert s.contains?(2)
assert s.contains?(1)
assert !s.contains?(4)
</code></pre>

<p>  end</p>

<p>  def test_uniqueness</p>

<pre><code>assert_equal [-32, 1, 2, 3], (s &lt;&lt; -32 &lt;&lt; -32 &lt;&lt; -32).to_a.sort
</code></pre>

<p>  end
end
```</p>

<p>And because I spotted you writing new code and yelled &ldquo;HEY USE RANTLY IT&rsquo;S SO COOL YIPEE&rdquo;, you add some property tests:</p>

<p>``` ruby
class DumbSetTest &lt; Minitest::Test
  # &hellip;
def test_contains_property</p>

<pre><code>property {
  array(range(0, 100)) { integer }
}.check { |vs|
  s = vs.inject(DumbSet.new) { |ds, v| ds &lt;&lt; v }
  assert vs.all? { |v| s.contains?(v) }
}
</code></pre>

<p>  end</p>

<p>  def test_uniqueness_property</p>

<pre><code>property {
  array(range(0, 100)) { integer }
}.check { |vs|
  ns = vs.inject(DumbSet.new) { |ds, v| ds &lt;&lt; v }
  rs = vs.inject(ns) { |ds, v| ds &lt;&lt; v }
  assert_equal vs.sort, ns.to_a.sort
}
</code></pre>

<p>  end
  # &hellip;
end<br/>
```</p>

<p>It looks good:</p>

<p>```
$ bundle exec ruby set_test.rb
Run options: &mdash;seed 15625</p>

<h1>Running:</h1>

<p>&hellip;&hellip;&hellip;.
success: 100 tests
..
&hellip;&hellip;&hellip;.
success: 100 tests
..</p>

<p>Finished in 0.119717s, 33.4121 runs/s, 1720.7247 assertions/s.</p>

<p>4 runs, 206 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>You then implement the removal of items:</p>

<p>``` ruby &ldquo;Set with delete&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-set-rb">https://gist.github.com/dodecaphonic/9934064#file-set-rb</a>
class DumbSet
  # &hellip;
  def delete(v)</p>

<pre><code>ls = storage
ns = DumbSet.new

while !ls.empty?
  if ls.head != v
    ns = ns &lt;&lt; v
  end

  ls = ls.tail
end

ns
</code></pre>

<p>  end
  # &hellip;
end</p>

<p>class DumbSetTest &lt; Minitest::TestCase
  # &hellip;
  def test_delete</p>

<pre><code>os = (((DumbSet.new &lt;&lt; 1) &lt;&lt; 2) &lt;&lt; 3)
ns = os.delete(1337)
assert_equal [1, 2, 3], ns.to_a.sort
ns = os.delete(3)
assert_equal [1, 2], ns.to_a.sort
ns = ns.delete(2)
assert_equal [1], ns.to_a.sort
ns = (ns &lt;&lt; 432).delete(1)
assert_equal [432], ns.to_a.sort
ns = ns.delete(432)
assert_equal [], ns.to_a.sort
</code></pre>

<p>  end
  # &hellip;
end
```</p>

<p>Your tests pass, but this time you don&rsquo;t listen to me about adding another property. You&rsquo;re just not that convinced they&rsquo;re worth their salt, and it looks good enough to ship with all the tests you&rsquo;ve added. The Pokémon Collecting app you work on can benefit from it right now, instead of 20 minutes from now. To production it goes.</p>

<p>Time goes by, and you&rsquo;ve forgotten about me and our little adventure. Your system is humming along and moved on to maintenance mode. Days have been kind of slow, so you decide to add an optimization you&rsquo;ve read about in Hacker News, detailing how a node.js program got a 10x speedup. You modify your delete method accordingly:</p>

<p>``` ruby &ldquo;Set Tests&rdquo; <a href="https://gist.github.com/dodecaphonic/9934064#file-set_test-rb">https://gist.github.com/dodecaphonic/9934064#file-set_test-rb</a>
  # &hellip;
  def delete(v)</p>

<pre><code>ls  = storage
tmp = DumbSet.new

while !ls.empty?
  if (ls.head != v) &amp;&amp; (ls.head &lt; 1500) # secret performance trick
    tmp = tmp &lt;&lt; ls.head
  end

  ls = ls.tail
end

tmp
</code></pre>

<p>  end
  # &hellip;
```</p>

<p>CI still reports all green.</p>

<p>A few days later, you receive a report from a User telling she deleted their Pokémon with power level 3, but her Pokémons with levels 4013, 1551 and 20000 disappeared. Your first line of defense &mdash; your tests &mdash; have not caught any issues. Sweating bullets and drowning in emails from stakeholders and other Pokémon fiends, you&rsquo;re about to collapse.</p>

<p>And then you remember: what about trying to express a property to see if it holds?</p>

<p>``` ruby
  # We&rsquo;ll add at most 10 unique items and then delete the first
  # 2. If there&rsquo;s anything wrong, this will blow up.
  def test_delete_property</p>

<pre><code>property {
  array(10) { range(0, 5000) }.uniq
}.check { |values|
  os = values.inject(DumbSet.new) { |s, v| s &lt;&lt; v }
  ds = values[0..1].inject(os) { |s, v| s.delete(v) }
  assert_equal (values.size - 2), ds.to_a.size
}
</code></pre>

<p>  end
```</p>

<p>You run it and it explodes:</p>

<p>```
$ bundle exec ruby set_test.rb
Run options: &mdash;seed 46455</p>

<h1>Running:</h1>

<p>&hellip;&hellip;&hellip;.
success: 100 tests
..
failure: 0 tests, on:
[384, 437, 120, 718, 1850, 4579, 3178, 4191, 533, 2669]
F
&hellip;&hellip;&hellip;.
success: 100 tests
&hellip;</p>

<p>Finished in 0.093858s, 63.9264 runs/s, 2248.0769 assertions/s.</p>

<p>  1) Failure:
DumbSetTest#test_delete_property [set_test.rb:69]:
Expected: 8
  Actual: 2</p>

<p>6 runs, 211 assertions, 1 failures, 0 errors, 0 skips
```</p>

<p>What? How come you&rsquo;ve only got 2 when you expected 8? Well, there must be something wrong with delete, after all. Let&rsquo;s take that array and try it on an <em>pry</em> session to see what happens:</p>

<p><code>
[1] pry(main)&gt; values = [384, 437, 120, 718, 1850, 4579, 3178, 4191, 533, 2669]
=&gt; [384, 437, 120, 718, 1850, 4579, 3178, 4191, 533, 2669]
[2] pry(main)&gt; os = values.inject(DumbSet.new) { |s, v| s &lt;&lt; v }
=&gt; #&lt;DumbSet...&gt;
[3] pry(main)&gt; values[0..1].inject(os) { |s, v| s.delete(v) }.to_a
=&gt; [718, 533]
</code></p>

<p>Wait a minute! Should delete also remove everything that&rsquo;s over 1000-ish? Is there anything in the code that stipulates such a thing? Maybe that node.js optimization was not so great after all. Let&rsquo;s remove it and run the tests:</p>

<p>```
$ bundle exec ruby set_test.rb
Run options: &mdash;seed 2727</p>

<h1>Running:</h1>

<p>.
&hellip;&hellip;&hellip;.
success: 100 tests
..
&hellip;&hellip;&hellip;.
success: 100 tests
.
&hellip;&hellip;&hellip;.
success: 100 tests
..</p>

<p>Finished in 0.099329s, 60.4053 runs/s, 3120.9415 assertions/s.</p>

<p>6 runs, 310 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>Voilà: properties have saved the day, and you&rsquo;ve learned not to trust Hacker News bravado ever again.</p>

<h2>Is using Rantly the same as using QuickCheck or ScalaCheck?</h2>

<p>Sort of. For one, you have to write your own generators every time you want something other than basic types, while both QuickCheck and ScalaCheck can figure out a lot by themselves. This can make expressing what you mean a lot easier, and you don&rsquo;t spend time debugging your <code>property</code> blocks in search of mistakes. That said, writing a generator for your own types requires only that you instantiate them in the <code>property</code> blocks with other auto-generated values.</p>

<p>Shrinking is not as good in Rantly. It works ok a lot of the time, but it could be improved. On the surface, from skimming the algorithms used in ScalaCheck and Rantly, it doesn&rsquo;t <em>seem</em> that different, but over that side of the line the patterns in minimization seem easier to spot.</p>

<p>There&rsquo;s also no mechanism to test stateful code. ScalaCheck has <a href="https://github.com/rickynils/scalacheck/wiki/User-Guide#stateful-testing">Commands</a> to help in modeling state changes, and I&rsquo;m aware <a href="https://github.com/manopapad/proper">PropEr</a> and <a href="http://www.quviq.com/">QuickCheck for Erlang</a> also provide something in that direction.</p>

<p>One minor thing is that integration with RSpec and MiniTest could be improved. Its output pollutes the test run, and on large suites it becomes hard to know the relationship between a failed property and a failed test. It should be easy to fix for anyone motivated. On that note, there&rsquo;s no ready-made extension for MiniTest (although adding one is trivial enough that I&rsquo;m sending a PR to fix it).</p>

<h2>Final considerations</h2>

<p>I hope I have proven, even if with a craptastic example, that property-testing can aid you in writing better Ruby code. Our community is great when it comes to using tests both as a design and as a verification tool, and QuickCheck (via Rantly) is a new way of thinking about them. You should keep your TDD/BDD to carve out your objects and responsibilities, but also add property checks where suitable to strengthen your confidence in the system.</p>
]]></content>
  </entry>
  
</feed>
